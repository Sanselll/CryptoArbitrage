"""
Data Loader

Loads simulated execution data from CSV files generated by HistoricalCollector.
"""

import pandas as pd
import numpy as np
from pathlib import Path
from typing import Optional, Tuple
from datetime import datetime


class DataLoader:
    """
    Load and prepare training data from HistoricalCollector CSV exports.
    """

    def __init__(self, data_path: Optional[Path] = None):
        """
        Initialize data loader.

        Args:
            data_path: Path to CSV file or directory containing CSV files
        """
        self.data_path = Path(data_path) if data_path else None
        self.df = None

    def load_csv(self, csv_path: Path) -> pd.DataFrame:
        """
        Load data from a single CSV file.

        Args:
            csv_path: Path to CSV file

        Returns:
            DataFrame with loaded data
        """
        print(f"Loading data from {csv_path}...")

        df = pd.read_csv(csv_path)

        print(f"✅ Loaded {len(df):,} records")
        print(f"   Columns: {len(df.columns)}")
        print(f"   Date range: {df['entry_time'].min()} to {df['entry_time'].max()}")

        # Convert date columns to datetime
        date_columns = ['entry_time', 'exit_time']
        for col in date_columns:
            if col in df.columns:
                df[col] = pd.to_datetime(df[col])

        self.df = df
        return df

    def load_multiple_csvs(self, csv_dir: Path, pattern: str = "*.csv") -> pd.DataFrame:
        """
        Load and concatenate multiple CSV files.

        Args:
            csv_dir: Directory containing CSV files
            pattern: File pattern to match (e.g., "*.csv")

        Returns:
            Concatenated DataFrame
        """
        csv_files = list(Path(csv_dir).glob(pattern))

        if not csv_files:
            raise ValueError(f"No CSV files found in {csv_dir} matching pattern {pattern}")

        print(f"Found {len(csv_files)} CSV files")

        dfs = []
        for csv_file in csv_files:
            df = pd.read_csv(csv_file)
            dfs.append(df)
            print(f"  ✅ Loaded {csv_file.name}: {len(df):,} records")

        combined_df = pd.concat(dfs, ignore_index=True)

        print(f"\n✅ Total: {len(combined_df):,} records")

        # Convert date columns
        date_columns = ['entry_time', 'exit_time']
        for col in date_columns:
            if col in combined_df.columns:
                combined_df[col] = pd.to_datetime(combined_df[col])

        self.df = combined_df
        return combined_df

    def get_summary_stats(self) -> dict:
        """
        Get summary statistics of the loaded data.

        Returns:
            Dictionary with summary statistics
        """
        if self.df is None:
            raise ValueError("No data loaded. Call load_csv() or load_multiple_csvs() first.")

        df = self.df

        # Profitability stats
        profitable_count = (df['target_was_profitable'] == True).sum()
        profitable_pct = profitable_count / len(df) * 100

        return {
            'total_records': len(df),
            'date_range': {
                'start': df['entry_time'].min(),
                'end': df['entry_time'].max()
            },
            'profitability': {
                'profitable_count': profitable_count,
                'unprofitable_count': len(df) - profitable_count,
                'win_rate_pct': profitable_pct
            },
            'profit_stats': {
                'mean_profit_pct': df['target_profit_pct'].mean(),
                'median_profit_pct': df['target_profit_pct'].median(),
                'std_profit_pct': df['target_profit_pct'].std(),
                'min_profit_pct': df['target_profit_pct'].min(),
                'max_profit_pct': df['target_profit_pct'].max()
            },
            'duration_stats': {
                'mean_hold_hours': df['target_hold_hours'].mean(),
                'median_hold_hours': df['target_hold_hours'].median(),
                'min_hold_hours': df['target_hold_hours'].min(),
                'max_hold_hours': df['target_hold_hours'].max()
            },
            'symbols': {
                'unique_count': df['symbol'].nunique(),
                'symbols': df['symbol'].unique().tolist()
            },
            'strategies': {
                'unique_count': df['strategy'].nunique(),
                'strategies': df['strategy'].unique().tolist()
            },
            'missing_values': df.isnull().sum().to_dict()
        }

    def print_summary(self) -> None:
        """
        Print summary statistics in a readable format.
        """
        stats = self.get_summary_stats()

        print("\n" + "=" * 60)
        print("DATA SUMMARY")
        print("=" * 60)

        print(f"\nTotal Records: {stats['total_records']:,}")
        print(f"Date Range: {stats['date_range']['start']} to {stats['date_range']['end']}")

        print(f"\n📊 Profitability:")
        print(f"   Profitable: {stats['profitability']['profitable_count']:,} ({stats['profitability']['win_rate_pct']:.1f}%)")
        print(f"   Unprofitable: {stats['profitability']['unprofitable_count']:,}")

        print(f"\n💰 Profit Statistics:")
        print(f"   Mean: {stats['profit_stats']['mean_profit_pct']:.2f}%")
        print(f"   Median: {stats['profit_stats']['median_profit_pct']:.2f}%")
        print(f"   Std Dev: {stats['profit_stats']['std_profit_pct']:.2f}%")
        print(f"   Range: [{stats['profit_stats']['min_profit_pct']:.2f}%, {stats['profit_stats']['max_profit_pct']:.2f}%]")

        print(f"\n⏱️  Hold Duration:")
        print(f"   Mean: {stats['duration_stats']['mean_hold_hours']:.1f} hours")
        print(f"   Median: {stats['duration_stats']['median_hold_hours']:.1f} hours")
        print(f"   Range: [{stats['duration_stats']['min_hold_hours']:.1f}, {stats['duration_stats']['max_hold_hours']:.1f}] hours")

        print(f"\n📈 Symbols: {stats['symbols']['unique_count']} unique")
        print(f"   {', '.join(stats['symbols']['symbols'][:10])}" + (" ..." if len(stats['symbols']['symbols']) > 10 else ""))

        print(f"\n🎯 Strategies: {stats['strategies']['unique_count']} unique")
        for strategy in stats['strategies']['strategies']:
            print(f"   - {strategy}")

        print("\n" + "=" * 60)

    def split_train_test(
        self,
        test_size: float = 0.2,
        random_state: int = 42,
        stratify_column: Optional[str] = None
    ) -> Tuple[pd.DataFrame, pd.DataFrame]:
        """
        Split data into training and testing sets.

        Args:
            test_size: Proportion of data for testing (0.0 to 1.0)
            random_state: Random seed for reproducibility
            stratify_column: Column to use for stratified splitting (e.g., 'target_was_profitable')

        Returns:
            (train_df, test_df)
        """
        if self.df is None:
            raise ValueError("No data loaded. Call load_csv() first.")

        from sklearn.model_selection import train_test_split

        stratify = self.df[stratify_column] if stratify_column else None

        train_df, test_df = train_test_split(
            self.df,
            test_size=test_size,
            random_state=random_state,
            stratify=stratify
        )

        print(f"\n✅ Data Split:")
        print(f"   Training: {len(train_df):,} records ({len(train_df)/len(self.df)*100:.1f}%)")
        print(f"   Testing: {len(test_df):,} records ({len(test_df)/len(self.df)*100:.1f}%)")

        return train_df, test_df

    def get_feature_target_split(
        self,
        df: pd.DataFrame,
        target_column: str
    ) -> Tuple[pd.DataFrame, pd.Series]:
        """
        Split DataFrame into features (X) and target (y).

        Args:
            df: DataFrame to split
            target_column: Name of target column

        Returns:
            (X, y) where X is features, y is target
        """
        # Target columns (should not be in features)
        target_columns = [
            'target_hold_hours',
            'target_profit_pct',
            'target_profit_usd',
            'target_was_profitable',
            'peak_profit_pct',
            'max_drawdown_pct',
            'funding_payments_count',
            'total_funding_usd'
        ]

        # Also exclude non-feature columns
        exclude_columns = target_columns + [
            'entry_time',
            'exit_time',
            'entry_long_price',  # Prices are outcome-dependent
            'entry_short_price',
            'exit_long_price',
            'exit_short_price',
            'total_fees_usd'  # Calculated from position size
        ]

        feature_columns = [col for col in df.columns if col not in exclude_columns]

        X = df[feature_columns].copy()
        y = df[target_column].copy()

        return X, y
